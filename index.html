<!DOCTYPE html>
<html lang="en">

<head>
	<title>Aria Odyssey</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-image: url('milkyway.jpg');
      background-size:cover;
      	/*background-color: #f0f0f0;*/
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<script src="assets/js/three.js"></script>
  <script src="assets/js/controls/OrbitControls.js"></script>
	<script src="assets/js/renderers/Projector.js"></script>
	<script src="assets/js/renderers/CanvasRenderer.js"></script>
	<script src="assets/js/loaders/GLTFLoader.js"></script>
	<script src="assets/js/controls/TrackballControls.js"></script>
  <script src="assets/js/Detector.js"></script>
  <script id="norm-vert-shader" type="x-shader/x-vertex">
    attribute vec4 tangent;

    uniform vec2 uvScale;
    uniform vec3 lightPosition;

    varying vec2 vUv;
    varying mat3 tbn;
    varying vec3 vLightVector;

    void main() {
        vUv = uvScale * uv;

        /** Create tangent-binormal-normal matrix used to transform
            coordinates from object space to tangent space */
        vec3 vNormal = normalize(normalMatrix * normal);
        vec3 vTangent = normalize( normalMatrix * tangent.xyz );
        vec3 vBinormal = normalize(cross( vNormal, vTangent ) * tangent.w);
        tbn = mat3(vTangent, vBinormal, vNormal);

        /** Calculate the vertex-to-light vector */
        vec4 lightVector = viewMatrix * vec4(lightPosition, 1.0);
        vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
        vLightVector = normalize(lightVector.xyz - modelViewPosition.xyz);

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script id="norm-frag-shader" type="x-shader/x-fragment">
    uniform sampler2D textureMap;
    uniform sampler2D normalMap;

    varying vec2 vUv;
    varying mat3 tbn;
    varying vec3 vLightVector;

    void main() {
        /** Transform texture coordinate of normal map to a range (-1, 1) */
        vec3 normalCoordinate = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;

        /** Transform the normal vector in the RGB channels to tangent space */
        vec3 normal = normalize(tbn * normalCoordinate.rgb);

        /** Lighting intensity is calculated as dot of normal vector and
            the vertex-to-light vector */
        float intensity = max(0.07, dot(normal, vLightVector));
        vec4 lighting = vec4(intensity, intensity, intensity, 1.0);

        /** Final color is calculated with the lighting applied */
        gl_FragColor = texture2D(textureMap, vUv) * lighting;
    }
  </script>
	<script>
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		var gltf = null;
		var container;

		var camera, scene;

    var renderer = new THREE.WebGLRenderer( {alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var normVertShader = document.getElementById('norm-vert-shader');
    var normFragShader = document.getElementById('norm-frag-shader');

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 800;


			scene = new THREE.Scene();
      var spotLight2 = new THREE.SpotLight( 0x5192e9 );
      spotLight2.position.set( 40, 30, 30 );
      spotLight2.intensity = 1.5;
      scene.add( spotLight2 );

      var loader = new THREE.GLTFLoader();
      // var url = "THISONE.gltf";
      // loader.load(url, function (data) {
  		// 	gltf = data;
  		// 	var object = gltf.scene;
  		// 	island = object;
      //   island.position.set(0,0,0);
      //   island.scale.set(0.5,0.5,0.5);
      //   scene.add(island);
      // });

      createMoon('assets/maps/moon.jpg', 'assets/maps/normal.jpg')


			// THREE.GLTFLoader.Shaders.update(scene, camera);
			// controls.update();
      function animate() {
			}

			animate();
		}

    function createMoon(textureMap, normalMap) {
      var radius = 100;
      var xSegments = 50;
      var ySegments = 50;
      var geo = new THREE.SphereGeometry(radius, xSegments, ySegments);
      var light = {
        speed: 0.1,
        distance: 1000,
        position: new THREE.Vector3(0, 0, 0),
        orbit: function (center, time) {
            this.position.x =
                (center.x + this.distance) * Math.sin(time * -this.speed);

            this.position.z =
                (center.z + this.distance) * Math.cos(time * this.speed);
        }
      };

      var mat = new THREE.ShaderMaterial({
          uniforms: {
              lightPosition: {
                  type: 'v3',
                  value: light.position
              },
              textureMap: {
                  type: 't',
                  value: textureMap
              },
              normalMap: {
                  type: 't',
                  value: normalMap
              },
              uvScale: {
                  type: 'v2',
                  value: new THREE.Vector2(1.0, 1.0)
              }
          },
          vertexShader: normVertShader.innerText,
          fragmentShader: normFragShader.innerText
      });

      var mesh = new THREE.Mesh(geo, mat);
      mesh.geometry.computeTangents();
      mesh.position.set(0, 0, 0);
      mesh.rotation.set(0, 180, 0);
      scene.add(mesh);
      // return mesh;

   }


		window.addEventListener('resize', onWindowResize, false);



		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}


		function animate() {

			requestAnimationFrame(animate);
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}
	</script>


</body>

</html>
